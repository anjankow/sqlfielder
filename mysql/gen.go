//go:build ignore

package main

// Based on https://cs.opensource.google/go/go/+/master:src/image/color/palette/gen.go
// This program generates fields for SQL queries from scanners. Invoke it as
//	go run gen.go -output sql_fields.go

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/go/packages"
)

var outputFilename = flag.String("output", "sql_fields.go", "output file name")

// Comments that can be used next to the Scan function arguments
const (
	// skipComment is used to skip this and the following arguments
	skipComment = "sqlfieldgen:skip"
	// prefixComment is used to indicate the SELECT query prefix of a given argument
	prefixComment = "sqlfieldgen:prefix="
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("sql-fields-gen: ")

	flag.Parse()

	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Code generated by go run gen.go -output %s; DO NOT EDIT.\n", *outputFilename)
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package mysql")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "const (")

	ctx := context.Background()
	// Load mysql package
	pkg, err := loadPackage(ctx, ".")
	if err != nil {
		log.Fatal("failed to load the package: ", err)
	}

	// Parse it searching for Scan invocations
	parsed, err := parsePackage(pkg)
	if err != nil {
		log.Fatal("failed to parse the package: ", err)
	}

	// Convert the parsed functions into constants to be used in SQL queries.
	if err := generate(&buf, parsed); err != nil {
		log.Fatal("failed to generate: ", err)
	}

	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, ")")

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = os.WriteFile(*outputFilename, data, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

// loadPackage loads the package in the given directory parsing each file for further processing.
func loadPackage(ctx context.Context, dir string) (pkg *packages.Package, err error) {
	parseMode := packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo | packages.LoadAllSyntax
	cfg := packages.Config{
		Context: ctx,
		Mode:    parseMode,
		Dir:     dir,
		ParseFile: func(fset *token.FileSet, filename string, data []byte) (*ast.File, error) {
			var mode parser.Mode
			switch {
			case filename == *outputFilename,
				strings.HasSuffix(filename, "_with_trace.go"),
				strings.HasSuffix(filename, "_test.go"):
				// No need for parsing
				mode = parser.PackageClauseOnly
			default:
				mode = parser.ParseComments | parser.SkipObjectResolution | parser.AllErrors
			}

			return parser.ParseFile(fset, filename, data, mode)
		},
	}
	pkgs, err := packages.Load(&cfg)
	if err != nil {
		return
	}

	for _, p := range pkgs {
		if p.Name == "mysql" {
			return p, nil
		}
	}

	return nil, errors.New("package mysql not found")
}

// parsePackage goes through each file in the package and looks for scan... function declarations.
// If found, each declaration in these functions is parsed to find Scan invocations.
// Scan invocations are processed to find the arguments and their corresponding prefixes.
func parsePackage(pkg *packages.Package) ([]ParsedScanFunc, error) {
	parsedScans := make([]ParsedScanFunc, 0)
	for _, file := range pkg.Syntax {
		if len(file.Decls) == 0 {
			// No declarations, no need to load a comment map
			continue
		}

		cmap := ast.NewCommentMap(pkg.Fset, file, file.Comments)
		errs := make([]error, 0)

		for _, decl := range file.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				// Find `func scan...` functions declared in every file
				if strings.HasPrefix(fn.Name.Name, "scan") {

					// Found it! Now do through each statement inside the function body.
					// Look for for lines like `err := s.Scan(`
					// so an assignment, which right hand side is a call expression to `Scan`.
					for _, stmt := range fn.Body.List {
						switch stmt := stmt.(type) {
						case *ast.ForStmt:
							// Some s.Scan calls might be placed in a for loop.
							// Then parse each declaration inside it.
							for _, stmt := range stmt.Body.List {
								assignment, ok := stmt.(*ast.AssignStmt)
								if !ok {
									continue
								}
								scanFunctionCall, err := parseAssignmentStatement(assignment, fn, cmap)
								if err != nil {
									return nil, err
								}
								if scanFunctionCall != nil {
									parsedScans = append(parsedScans, *scanFunctionCall)
								}
							}
						case *ast.AssignStmt:
							scanFunctionCall, err := parseAssignmentStatement(stmt, fn, cmap)
							if err != nil {
								return nil, err
							}
							if scanFunctionCall != nil {
								parsedScans = append(parsedScans, *scanFunctionCall)
							}
						}
					}
				}
			}
		}
	}

	return parsedScans, nil
}

// ScanArg is a single argument to a Scan function
type ScanArg struct {
	// Name is the name of the field, e.g. in object.Field.ScanDst, the name is ScanDst
	Name string
	// Path represents all that stands before the field name,
	// e.g. in object.Field.ScanDst, the path is object.Field
	Path string
	// Expr is the underlying expression, used only for debugging purposes.
	Expr ast.Expr
}

// ParsedScanFunc is the result of parsing a Scan function call
type ParsedScanFunc struct {
	// FuncName is the name of the function calling Scan method.
	// It's expected to be private and called `scan...`, e.g. `scanObject
	FuncName string
	// Args are the arguments to the Scan function
	Args []ScanArg
	// Prefixes maps a field "path" to a SQL prefix in a SELECT statement.
	// All arguments with the same path, e.g. object.Field1.Arg1 and object.Field1.Arg2,
	// share the same prefix, so it's enough to declare it once.
	Prefixes map[string]string
}

// parseAssignmentStatement parses assignment statement, like `a = b`,
// searching for Scan method calls, so assignments like `res := s.Scan(...)`.
// If such assignment is found, it parses it, getting the arguments and corresponding prefixes.
func parseAssignmentStatement(stmt *ast.AssignStmt, fn *ast.FuncDecl, cmap ast.CommentMap) (*ParsedScanFunc, error) {

	for _, rhs := range stmt.Rhs {
		callExpr, ok := rhs.(*ast.CallExpr)
		if !ok {
			continue
		}
		selectorExprScan, ok := callExpr.Fun.(*ast.SelectorExpr)
		if !ok {
			continue
		}
		if selectorExprScan.Sel.Name != "Scan" {
			continue
		}

		// Found Scan method call!
		// There should be only one in a single scan... function.
		return parseScanInvocation(callExpr, fn, cmap)
	}

	return nil, nil
}

// parseScanInvocation parses a single `Scan` method invocation, gathering the arguments and corresponding prefixes.
// If there is no error, the function will always return a non-nil ParsedScanFunc.
func parseScanInvocation(scanCall *ast.CallExpr, fn *ast.FuncDecl, cmap ast.CommentMap) (*ParsedScanFunc, error) {
	// `.Scan(` arguments
	args := make([]ScanArg, 0)
	// sql prefixes given in the comments
	prefixes := make(map[string]string)

	// In case of error, continue to collect all the possible errors at once.
	errs := make([]error, 0)
	for i, arg := range scanCall.Args {

		// Each of the arguments should be a unary expression: a pointer to a variable
		unaryExpl, ok := arg.(*ast.UnaryExpr)
		if !ok {
			errs = append(errs, NewInvalidTypeErr(fmt.Sprintf("argument #%v", i), arg))
			continue
		}

		// If a field is marked with a skip comment, we will stop here.
		// Next arguments are not included in the list.
		comment := cmap.Filter(arg)
		if strings.Contains(comment.String(), skipComment) {
			log.Default().Printf("%s: skipping param %v\n", fn.Name.Name, unaryExpl.X)
			break
		}

		// Get the argument.
		// If a field is simple variable, e.g. var count int,
		// then the type is ast.Ident.
		// If it's a struct member, it's a ast.SelectorExpr.
		var scanArg ScanArg
		switch expr := unaryExpl.X.(type) {
		case *ast.Ident:
			log.Default().Printf("%s: found var %q, use %q comment to exclude it from generation if needed\n",
				fn.Name.Name, expr.Name, skipComment)
			scanArg = ScanArg{
				Name: expr.Name,
				Path: "",
				Expr: expr,
			}
		case *ast.SelectorExpr:
			arg, err := parseScanArg(expr)
			if err != nil {
				// Continue parsing, we want to catch all errors at once
				errs = append(errs, err)
				continue
			}

			scanArg = arg
		default:
			errs = append(errs, NewInvalidTypeErr(fmt.Sprintf("argument #%v", i), arg))
			continue
		}

		args = append(args, scanArg)

		// Check if there is a prefix comment.
		// The prefix is a string before the column name in a sql query.
		if strings.Contains(comment.String(), prefixComment) {
			parts := strings.Split(comment.String(), prefixComment)
			if len(parts) != 2 {
				errs = append(errs, NewInvalidCommentErr(fmt.Sprintf("argument #%v", i), comment.String()))
				continue
			}

			// Assign the prefix. It will be used by all the fields with the same path.
			prefixes[scanArg.Path] = parts[1]
		}
	}

	if len(errs) > 0 {
		return nil, ParseFunError{
			Errs:         errs,
			FunctionName: fn.Name.Name,
		}
	}

	if len(args) == 0 {
		return nil, fmt.Errorf("%s: no Scan arguments found", fn.Name.Name)
	}

	return &ParsedScanFunc{
		FuncName: fn.Name.Name,
		Args:     args,
		Prefixes: prefixes,
	}, nil

}

type ParseFunError struct {
	Errs         []error
	FunctionName string
}

func (e ParseFunError) Error() string {
	msg := fmt.Sprintf("error parsing function %q:\n", e.FunctionName)
	for _, err := range e.Errs {
		msg += err.Error() + "\n"
	}
	return msg
}

func NewInvalidTypeErr(argument string, value any) error {
	return ParseArgError{
		Argument: argument,
		Value:    value,
		Reason:   ReasonWrongType,
	}
}

func NewInvalidCommentErr(argument string, comment string) error {
	return ParseArgError{
		Argument: argument,
		Value:    comment,
		Reason:   ReasonWrongComment,
	}
}

const (
	ReasonWrongType = iota
	ReasonWrongComment
)

type ParseArgError struct {
	Argument string
	Value    any
	Reason   int
}

func (e ParseArgError) Error() string {
	switch e.Reason {
	case ReasonWrongType:
		return fmt.Sprintf("%s: wrong type %T of the expression (%+v); expected a pointer to a struct field or a pointer to a variable",
			e.Argument, e.Value, e.Value)
	case ReasonWrongComment:
		return fmt.Sprintf("%s: unexpected comment format: %q, should be \"%s<value>\"\n",
			e.Argument, e.Value, prefixComment)
	default:
		panic("invalid error reason given, fix me please")
	}

}

// parseScanArg parses a single Scan argument that is a pointer to a member of a struct,
// e.g. `&object.Field`.
func parseScanArg(expr *ast.SelectorExpr) (ScanArg, error) {
	path := make([]string, 0)

	fieldName := expr.Sel.Name
	scanArg := ScanArg{
		Name: fieldName,
		Expr: expr,
	}

	// Use pointer to traverse the nested SelectorExpressions.
	var ptr *ast.SelectorExpr = expr

	// Parse the path - e.g. in &object.Field1.Field2.Field3,
	// the path is object.Field1.Field2 and the name is Field3
	for {

		switch inner := ptr.X.(type) {
		case *ast.SelectorExpr:
			path = append(path, inner.Sel.Name)
			// Move the pointer to the inner SelectorExpr
			ptr = inner
		case *ast.Ident:
			// If it's a ast.Ident, we reached the final path fragment.
			// In the example &object.Field1.Field2.Field3,
			// the final fragment is `object`.
			path = append(path, inner.Name)
			// Reverse the path, because the last fragment is actually the first one we read.
			slices.Reverse(path)
			scanArg.Path = strings.Join(path, ".")
			return scanArg, nil
		default:
			return ScanArg{}, NewInvalidTypeErr(fieldName, ptr.X)
		}
	}
}

// generate writes to the given buffer string constants for each `Scan` function
// invocation in a form of SELECT query parameters.
func generate(buf *bytes.Buffer, parsed []ParsedScanFunc) error {

	for _, p := range parsed {
		constName := p.FuncName + "Fields"
		args := make([]string, 0, len(p.Args))
		for _, arg := range p.Args {
			prefix, ok := p.Prefixes[arg.Path]
			if !ok {
				prefix = strings.Split(arg.Path, ".")[0]
			}
			name := strcase.ToSnake(arg.Name)
			args = append(args, fmt.Sprintf("%s.%s", prefix, name))
		}

		fmt.Fprintf(buf, "%s = %q\n", constName, strings.Join(args, ", "))
	}
	return nil
}
