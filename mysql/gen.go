//go:build ignore

package main

// Based on https://cs.opensource.google/go/go/+/master:src/image/color/palette/gen.go
// This program generates fields for SQL queries from scanners. Invoke it as
//	go run gen.go -output sql_fields.go

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var outputFilename = flag.String("output", "sql_fields.go", "output file name")

func main() {
	log.SetFlags(0)
	log.SetPrefix("sql-fields-gen: ")

	flag.Parse()

	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Code generated by go run gen.go -output %s; DO NOT EDIT.\n", *outputFilename)
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "package mysql")
	fmt.Fprintln(&buf)
	// fmt.Fprintln(&buf, `import "image/color"`)
	// fmt.Fprintln(&buf)

	ctx := context.Background()
	pkg, err := loadPackage(ctx, ".")
	if err != nil {
		log.Fatal("failed to load the package: ", err)
	}

	parsed, err := parsePackage(ctx, pkg)
	if err != nil {
		log.Fatal("failed to parse the package: ", err)
	}

	if err := generate(&buf, parsed); err != nil {
		log.Fatal("failed to generate: ", err)
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	err = os.WriteFile(*outputFilename, data, 0644)
	if err != nil {
		log.Fatal(err)
	}
}

type ParseOutput struct {
	scanFuncs []*ast.FuncDecl
}

func loadPackage(ctx context.Context, dir string) (pkg *packages.Package, err error) {
	parseMode := packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo | packages.LoadAllSyntax
	cfg := packages.Config{
		Context: ctx,
		Mode:    parseMode,
		Dir:     dir,
		ParseFile: func(fset *token.FileSet, filename string, data []byte) (*ast.File, error) {
			switch {
			case filename == *outputFilename,
				strings.HasSuffix(filename, "_with_trace.go"),
				strings.HasSuffix(filename, "_test.go"):
				return parser.ParseFile(fset, filename, data, parser.PackageClauseOnly)
			default:
				return parser.ParseFile(fset, filename, data, parser.SkipObjectResolution|parser.AllErrors)
			}

		},
	}
	pkgs, err := packages.Load(&cfg)
	if err != nil {
		return
	}

	for _, p := range pkgs {
		if p.Name == "mysql" {
			return p, nil
		}
	}

	return nil, errors.New("package mysql not found")
}

func parsePackage(ctx context.Context, pkg *packages.Package) (*ParseOutput, error) {

	scanFuncs := make([]*ast.FuncDecl, 100)
	for i, file := range pkg.Syntax {
		_ = i
		// log.Default().Println(pkg.CompiledGoFiles[i], ":", "decl len (", len(file.Decls), ")")

		for _, decl := range file.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				// Handle function declaration
				if strings.HasPrefix(fn.Name.Name, "scan") {
					scanFuncs = append(scanFuncs, fn)
					for _, stmt := range fn.Body.List {
						switch stmt := stmt.(type) {
						// case *ast.DeclStmt:
						// 	fmt.Printf("type: %T, statement: %s\n", stmt, stmt.Decl)
						// case *ast.ExprStmt:
						// 	fmt.Printf("type: %T, statement: %s\n", stmt, stmt.X)
						case *ast.AssignStmt:
							fmt.Printf("file: %s\n", pkg.CompiledGoFiles[i])
							fmt.Printf("type: %T, position: %v\n", stmt, stmt.Pos())
							fmt.Print("LHS: ")
							for _, lhs := range stmt.Lhs {
								fmt.Printf("%T - %v, ", lhs, lhs)
							}
							fmt.Println("\nRHS:")
							for _, rhs := range stmt.Rhs {
								callExpr, ok := rhs.(*ast.CallExpr)
								if !ok {
									continue
								}
								selectorExprScan, ok := callExpr.Fun.(*ast.SelectorExpr)
								if !ok {
									continue
								}
								fmt.Printf("FUNC: %v %v, args: %v\n", selectorExprScan.Sel.Name, callExpr.Fun, callExpr.Args)
							}
							// case *ast.ReturnStmt:
							// 	fmt.Printf("type: %T, statement: %s\n", stmt, stmt.Results)
							// case *ast.ForStmt:
							// 	fmt.Printf("type: %T, statement: %s\n", stmt, stmt.Cond)
							// default:
							// 	fmt.Printf("type NOT HANDLED: %T, statement: %s\n", stmt, stmt)
						}
					}
				}
			}
		}
	}

	return &ParseOutput{
		scanFuncs: scanFuncs,
	}, nil
}

func generate(buf *bytes.Buffer, parsed *ParseOutput) error {
	return nil
}
